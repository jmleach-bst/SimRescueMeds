---
output: github_document
bibliography: "inst/REFERENCES.bib"
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# `SimRescueMeds`

<!-- badges: start -->
<!-- badges: end -->

The goal of `SimRescueMeds` is to enable (relatively) simple simulation studies that impose rescue medication (or really any intercurrent event) on longitudinal data. 

1. Longitudinal data is simulated according a linear mixed model. This is the data one would observe if no intercurrent event, e.g., rescue therapy, occurs.
2. Rescue medication/intercurrent events are simulated using models adapted from @Thomadakis2019, which allows for reasonably straightforward generation of events that, if excluding post-event data, produce MCAR, MAR, or MNAR missingness on the longitudinal data using either exponential or Weibull models. 
3. We also intend to develop functions that can modify post-event data. Only one of these has been developed thus far, `rescue_effect_means()`; see documentation for details. 

## Installation

You can install the development version of `SimRescueMeds` from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("jmleach-bst/SimRescueMeds")
```

## Simulation examples

First, load the package.

```{r example}
library(SimRescueMeds)
```

Use `build_design_matrix()` to build the design matrix for the fixed effects, in which you specify the number of individuals in each group `N_t` and `N_c`, the number of time points `K`, the starting time, and time scale. The example below scales such that the file time point has $t = 1$, e.g., 1-year follow-up.

```{r}
xmat_t <- build_design_matrix(
    N_t = 1,
    N_c = 0,
    K = 5,
    time_start = 0,
    time_scale = 1/4
  )
xmat_t
```

Use `simulate_lmm_rct()` to generate data sets based on the linear mixed model, which generates data from a multivariate Normal distribution. Here, we specify a single-individual design matrix for each of 2 treatment groups and the number of individuals in each group. Use `build_lmm_cov()` to more easily construct the covariance matrix as a function of random effects (co)variances and within-individual random error covariances.

```{r}
set.seed(3002242)
df <- simulate_lmm_rct(
  N_t = 50,
  N_c = 50,
  xmat_t = xmat_t,
  xmat_c = build_design_matrix(
    N_t = 0,
    N_c = 1,
    K = 5,
    time_start = 0,
    time_scale = 1/4
  ),
  betas = c(
    beta0 = 8,
    beta1 = 0,
    beta2 = -1,
    beta3 = -1
  ),
  Sigma = build_lmm_cov(
    zmat = xmat_t[, c("intercept", "time")],
    re_sigma = c(1.15, 1.05),
    re_corr_mat = matrix(
      c(1, 0,
        0, 1),
      byrow = TRUE,
      nrow = 2
      ),
    ws_sigma = 1.25,
    ws_corr_mat = diag(5),
    print_intermediate = FALSE
    )
)

head(df, 10)
```

Simulate rescue therapy based on a proportional hazards model in the manner of @Thomadakis2019, which allows the hazard of rescue therapy within some interval $t_{i,j} \le t < t_{i,j+1}$ to be a function of the last observed outcome measurement, $y_{i,j}$, and the next measurement, $y_{i,j+1}$, the latter of which is unobserved in the study since it occurs after rescue therapy. While simple in some respects, this approach allows us to easily define MCAR $(\theta_1 = \theta_2 = 0)$, MAR $(\theta_1 \ne 0,\,\theta_2 = 0)$, or MNAR $(\theta_2 \ne 0)$. 

$$
h_i(t) = \lambda\exp\left(y_{i,j}\theta_1 + y_{i,j+1}\theta_2\right), \quad t_{i,j} \le t < t_{i,j+1}.
$$


```{r}
set.seed(707582)

rt <- sim_hazard_thomadakis_df(
  data = df,
  theta1 = 1/3,
  theta2 = 0,
  lambda = 0.05,
  dist = "exponential",
  print_intermediate = FALSE
)

head(rt)
```

Finally, for analysis we would exclude the events that occur post-event using `exclude_post_tte()`.

```{r}
post_rt <- exclude_post_tte(
  original_data = df,
  tte_data = rt
)

head(post_rt, 15)
```

## Calculation of Monte Carlo Standard Errors (MCSE)

It is good practice to report some measure of precision associated with the estimates from a simulation study, because in general the results can change if a new seed, and therefore new data, are generated. We largely follow @Morris2019 in using formulas for these calculations, but we also include options for jackknife estimation of MCSE, as described by @Koehler2009 and re-emphasized by @Kelter2024. These are general functions that are not necessarily dependent on simulating interrcurrent events. 

Consider a very simple example, in which we estimate the regression parameter $\beta$ from a simple linear model:

$$
Y_i = \alpha + X_i\beta + \epsilon_i 
$$
where $X_i$ is a binary predictor taking value 0 or 1 and $\epsilon_i \sim \mathcal{N}(0, \sigma^2$. This is straightforward and quick to simulate. Note that we would usually save both the data and the analysis, but for this demonstration it is unnecessary. Below we use `mcse_estimands()`, which reports several estimates and MCSE for some typical estimands of interest. In this case the data frame input only consists of a column for estimates of $\hat{\beta}$ and a column for estimates of $\widehat{SE}(\hat{\beta})$. We have arguments for `estimand_name` and `se_name`, which tells the function which columns are which, and we need to specify `true_value` in order to calculate, e.g., bias. We see that for this relatively simple model, even $M = 2500$ produces relatively small MCSE for every measure except percent-bias. In general, we may except the MCSE to decrease with increasing $M$.

```{r, message=FALSE}
# Set seed
set.seed(723862)

# Number of simulations
M <- 2500

# Sample size
N <- 150

# Parameters
alpha <- 0.5
beta <- 1.5
sigma <- 1.25

# Balanced groups
x <- c(
  rep(1, N/2),
  rep(0, N/2)
)

# Simulate data
beta_hat <- c()
se_hat <- c()
for (m in 1:M) {
  dfm <- data.frame(
    x = x,
    y = alpha + x*beta + rnorm(N, 0, sigma)
  )
  lm_m <- lm(
    formula = y ~ x,
    data = dfm 
  )
  beta_hat[m] <- coefficients(lm_m)["x"]
  se_hat[m] <- summary(lm_m)$coefficients["x", "Std. Error"]
}
df <- data.frame(beta_hat, se_hat)

knitr::kable(
  mcse_estimands(
    data = df,
    estimand_name = "beta_hat",
    se_name = "se_hat",
    include_bias_percent = TRUE,
    report_proportion = FALSE,
    true_value = beta
  )
)
```

# References {-}
